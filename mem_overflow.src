// mem_overflow
// This script performs a memory overflow attack on a remote or local computer.
    
import_code("/Tools/src/srm_lib/params.src")
import_code("/Tools/src/srm_lib/metaxploit.src")
import_code("/Tools/src/srm_lib/computer_explorer.src")
import_code("/Tools/src/srm_lib/file_explorer.src")
import_code("/Tools/src/srm_lib/lib_scan/lib_scan_utils.src")

add_param("ip_address or -l", true, false, "Either the IP address of the remote computer or the tag -l to use a local library")
add_param("port or lib", true, false, "Either the port to connect to the remote computer or the library file to use locally")
add_param("memory_addr", true, false, "The memory address to overflow")
add_param("unsec_value", true, false, "The unsecure value to write in the memory address")
add_param("-a", false, false, "The extra arguments to pass to the overflow function (optional)")
handle_help()

// Parse parameters
lib_path = params_map["port or lib"]
address =  params_map["ip_address or -l"]
port = null
if address != "-l" then
    port = params_map["port or lib"].to_int
end if
memory_zone = params_map.memory_addr
unsec_val = params_map.unsec_value
extra_args = params_map["-a"]


metaLib = null
// Start connection
if params.indexOf("-l") == null then
	// Remote use
	net_session = metaxploit.net_use( address, port )
	if not net_session then exit("Error: can't connect to net session")
	metaLib = net_session.dump_lib
else
	// Local use
	metaLib = metaxploit.load(lib_path)
	if metaLib == null then
		metaLib = metaxploit.load(current_path+"/"+lib_path)
	end if
	if metaLib == null then
		metaLib = metaxploit.load("/lib/"+lib_path)
	end if
end if
// Overflow
result = metaLib.overflow(memory_zone, unsec_val, extra_args)

if not result then exit("Program ended")
print("The overflow resulted in ["+typeof(result)+"]")

if typeof(result) == "shell" or typeof(result) == "file" or typeof(result) == "computer" then
	old_vuln_data = find_vuln_data(metaLib, memory_zone, unsec_val)
	access_level = ""

	if old_vuln_data != null then
		access_level = old_vuln_data.access_level
	end if

	if access_level == "" then
		print()
		access_level_in = user_input("Please manually update the access level for this vulnerability in the database (""r""/""root"")/(""u""/""user"")/(""g""/""guest""): ").upper
		if access_level_in == "R" or access_level_in == "ROOT" then
			access_level = "root"
		else if access_level_in == "U" or access_level_in == "USER" then
			access_level = "user"
		else if access_level_in == "G" or access_level_in == "GUEST" then
			access_level = "guest"
		else
			exit("Invalid access level input. Exiting.")
		end if
	end if
	make_vuln_data_row(metaLib, memory_zone, unsec_val, "", typeof(result), access_level)
end if

if typeof(result) == "shell" then
    decision = user_input("Do you want to start a terminal connection? (Y/n): ")
    if decision == "y" or decision == "Y" or decision == "" then
        // Start terminal
        result.start_terminal
    else
        print("Exiting without starting a terminal.")
    end if
else if typeof(result) == "file" then
    // Handle file connection
    print("Got file. Path: " + result.path())
	file_connection(result)
else if typeof(result) == "computer" then
    // Handle computer connection
    print("Got computer. Name: " + result.get_name)
	computer_connection(result)
else if result != 1 then
	print("Error: expected shell, obtained: " + result)
end if